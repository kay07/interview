#### 1、new和make的区别？
* new
  - 通常用于值类型
  - 返回值是一个指向类型的指针
  - 只分配内存
* make
  - 仅用于map，slice，chan
  - 返回值是一个类型
  - 分配内存并初始化
#### 2、数组和切片的区别？
* 数组
  - 长度固定
  - 值类型
* 切片
  - 长度不固定
  - 指针类型
#### 3、切片的扩容机制？
如果切片容量小于1024个元素，扩容是原来的2倍；如果容量超过1024，扩容是原来的1.25倍
#### 4、map和slice如何实现线程安全？
通过加锁可以实现；map可以使用sync.Map来替换
#### 5、进程，线程，协程的区别？
* 每个进程拥有自己独立的内存空间，进程间通讯上下文切换开销比较大，但相对安全
* 线程是进程的一个实体，线程间通过共享内存通讯
* 协程是用户态的轻量级线程，协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力
#### 6、协程有ID吗？
go1.4之前是有id的，之后就把id隐藏了，因为存在被滥用的情况，比如协程a被协程b给修改了行为，导致出现自己的协程被别人利用的情况。
#### 7、协程泄露是什么？
协程泄露是指协程创建后长时间得不到释放，不断有新协程创建导入内存耗尽。
协程泄露的情况主要包括：向无缓存chan发送数据，从无缓存chan接收数据，互斥锁没有解锁。
#### 8、switch的用法？
* 单个case可以出现多个匹配，如case 1,2,3：
* 默认只执行一个case，可以通过fallthrough来执行下一个case，且执行下一个case是无条件执行的，即不判断下一个case的条件
#### 9、select的用法？
* select用来处理io请求
* 每个case里必须有一个io操作
* 如果有多个case匹配，将随机执行一个case
#### 10、说说互斥锁和读写锁？
* 一个协程获得mutex后其他协程只能等待，直到其释放后才能使用
* RWMutex可以有多个读锁，但只能有一个写锁；读锁和写锁直接是互斥的
#### 11、channel的特点？
* 向nil channel发送数据或者接收数据会导致阻塞
* 向关闭的channel发送数据会导致panic，向关闭的channel接收数据，如果缓冲区为空，返回零值
* 无缓冲的channel是同步的，有缓冲的channel是异步的
#### 12、触发panic异常的场景有哪些？
* 空指针解析
* 下标越界
* 除数为0
* 调用panic函数
* 向关闭的channel写数据或者关闭一个已经关闭的channel
#### 13、引用类型有哪些？
map slice chan interface
#### 14、init函数调用顺序是什么？
先调用导入包的init函数，然后按顺序调用本包的init函数
#### 15、map如何实现顺序读取？
map本身不支持顺序读取，实现顺序读取可以将map的key放入切片中来实现
#### 16、说说for循环的特点？
* 支持continue跳过当前循环，支持break跳出循环
* 不支持逗号分隔的多个赋值语句，必须使用平衡赋值来初始化多个变量。如for a:=0,b:=10;a<b;a++,b--{}是不支持的，for i,j:=0,100;i<j ; i,j=i+1,j-1{}是支持的
#### 17、context包的用途？
context主要用于父子任务之间的同步取消信号，本质上是一种协程调度的方式。使用context时有两点值得注意：上游任务仅仅使用context通知下游任务不再需要，但不会直接干涉和中断下游任务的执行，由下游任务自行决定后续的处理操作，也就是说context的取消操作是无侵入的；context是线程安全的，因为context本身是不可变的（immutable），因此可以放心地在多个协程中传递使用。
#### 18、局部变量的分配位置？
go在编译的时候进行逃逸分析，来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。所以局部变量分配在堆上还是栈上都有可能
#### 19、说说go的并发模型？
* M（Machine）：系统内核
* P（Processor）：执行的上下文，维护一个goroutine队列，即runqueue。Processor是让我们从N:1调度到M:N调度的重要部分。一个M对应一个P
* G（Goroutine）：待执行的goroutine，有自己的栈空间。一个P可以有多个G
每个P运行完本地的runqueue后会从全局runqueue拉取新的队列，p也会周期性的检测全局runqueue，否则全局runqueue上的goroutine会得不到执行而饿死。当p中的runqueue执行完后会偷取其他p中一半的goroutine
#### 20、并发模型中没有p会怎样？
* 每个M都需要做内存缓存：会导致资源消耗过大
* 频繁的线程阻塞和解阻塞：存在syscall时，线程经常被阻塞，增加了很多性能开销
#### 20、说说go的垃圾回收机制？
* 标记清除法：从跟对象出发，标记所有存活的对象，回收未被标记的对象。在标记期间需要stw
* 三色标记法：所有对象默认白色，从跟对象出发，扫描所有可达对象标记灰色，从灰色对象找其引用对象并将该引用对象标记为灰色，同时自身标记为黑色，重复以上步骤，清除所有白色对象。缺点就是程序垃圾产生速度大于垃圾回收速度会导致垃圾越来越多，线程切换和上下文转换会导致垃圾回收成本增高
* 混合屏障保护：开始垃圾回收时所用栈上空间标记为黑色，期间在栈上创建的对象直接标记黑色，被删除的下游对象标记为灰色（删除屏障保护，弱三色不便性-黑色对象指向的白色对象至少包含一条由灰色经过白色的可达路径），被添加的下游对象标记为灰色（插入屏障保护，强三色不变性-黑色对象不会指向白色对象）。只有堆适用混合屏障保护，栈不会，为了防止降低占空间的运行效率。
